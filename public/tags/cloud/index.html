<!DOCTYPE html>
<html lang="en-us">
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <meta property="og:image" content="/images/og_img.png" />

        
        <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"}> <link rel="icon" type="image/png"
        sizes="32x32" href="/favicon-32x32.png"> <link rel="icon"
        type="image/png" sizes="16x16" href="/favicon-16x16.png">
        <link rel="manifest" href="/site.webmanifest"> 
        <link rel="alternate" type="application/rss+xml" href="https://darrenkwondev.github.io/tags/cloud/index.xml" title="darrenkwon.dev blog" />
         
        <title>cloud | darrenkwon.dev blog</title>
        

        
        <style>
            :root {
                --background: #ffffff;
            }
            html {
                background-color: var(--background);
            }
            body {
                background-color: var(--background);
            }
        </style>

        <link href="/fonts/Inter-Regular.woff2?v=4.0"
        rel="preload" type="font/woff2" as="font" crossorigin=""> <link href="/fonts/Inter-Italic.woff2?v=4.0" rel="preload"
        type="font/woff2" as="font" crossorigin=""> <link href="/fonts/Inter-Bold.woff2?v=4.0" rel="preload" type="font/woff2"
        as="font" crossorigin=""> <link href="/fonts/iosevka-regular.woff2" rel="preload" type="font/woff2"
        as="font" crossorigin=""> <link href="/fonts/iosevka-extended.woff2" rel="preload" type="font/woff2"
        as="font" crossorigin=""> 
        <link
            rel="stylesheet"
            type="text/css"
            href="/style.min.75bc201b2c903267a533f1355cb449e17a19963ad09ff79a67eba7ba87dc1df7.css"
            media="all"
        />
    </head>

    <body>
        <h1 class="site-title">
            <a href="/">drkdev</a>
        </h1>
        
        <nav>
            <ul class="menu">
                
                <li>
                    <a
                        tabindex="-1"
                        class="menu-link"
                        href="/"
                        >Home</a
                    >
                </li>
                
                <li>
                    <a
                        tabindex="-1"
                        class="menu-link"
                        href="/tags/"
                        >Tags</a
                    >
                </li>
                
                <li>
                    <a
                        tabindex="-1"
                        class="menu-link"
                        href="/about/"
                        >About</a
                    >
                </li>
                
            </ul>
        </nav>
        
    </body>
</html>


<h1>cloud</h1>
<ul class="post-list">
    

    <li>

    <div style="display: grid; grid-template-columns: 7em auto">
      <span class="date">Dec 27, 2023</span>
      
      <a class="bold-post-in-list" href="/posts/2023-12-27_from-home-to-internet/"
        >홈 네트워크 구성으로 알아보는 네트워크 기초</a
      >
      
    </div>

</li>



    
  </ul>


<br>



<footer>

<script defer>
    document.addEventListener("keydown", function (e) {
        if (document.activeElement.isContentEditable) {
            return false;
        }
        if (document.activeElement.tagName == "INPUT") {
            return false;
        }
        if (e.altKey || e.ctrlKey || e.shiftKey) {
            return false;
        }
        var key = e.key;
        if (key === "h") {
            e.preventDefault();
            e.stopPropagation();
            window.location.href = "/";
        } else if (key === "t") {
            e.preventDefault();
            e.stopPropagation();
            window.location.href = "/tags";
        } else if (key === "i") {
            e.preventDefault();
            e.stopPropagation();
            const inputs = document.querySelectorAll("input");
            for (let i = 0; i < inputs.length; i++) {
                if (inputs[i].offsetParent !== null) {
                    inputs[i].selectionStart = inputs[i].selectionEnd =
                        inputs[i].value.length;
                    inputs[i].focus();
                    break;
                }
            }
        }
        return false;
    });
</script>


<script defer>
    function scrollHandler() {
        const anchors = Array.from(
            document.querySelectorAll("body h2, body h3")
        );

        window.addEventListener("scroll", function () {
            var scrollTop =
                window.pageYOffset || document.documentElement.scrollTop;

            
            for (var i = 0; i < anchors.length; i++) {
                var anchorId = anchors[i].getAttribute("id");
                var link = document.querySelector(
                    'nav ul li a[href="#' + anchorId + '"]'
                );
                if (link) {
                    link.classList.remove("active-toc");
                }
            }

            
            for (var i = anchors.length - 1; i >= 0; i--) {
                var offsetTop = anchors[i].offsetTop;
                if (scrollTop > offsetTop - 75) {
                    var anchorId = anchors[i].getAttribute("id");
                    var link = document.querySelector(
                        'nav ul li a[href="#' + anchorId + '"]'
                    );
                    if (link) {
                        link.classList.add("active-toc");
                        break;
                    }
                }
            }
        });
    }
    setTimeout(scrollHandler, 100);
</script>



<script>
window.store = {
    
    "https:\/\/darrenkwondev.github.io\/": {
        "title": "darrenkwon.dev blog",
        "tags": [],
        "content": "", 
        "url": "https:\/\/darrenkwondev.github.io\/"
    },
    
    "https:\/\/darrenkwondev.github.io\/tags\/kernel\/": {
        "title": "kernel",
        "tags": [],
        "content": "", 
        "url": "https:\/\/darrenkwondev.github.io\/tags\/kernel\/"
    },
    
    "https:\/\/darrenkwondev.github.io\/posts\/2023-12-27_kernel_study_02.md\/": {
        "title": "kernel study 02: top을 통해 확인할 수 있는 프로세스 정보들",
        "tags": ["linux","system_engineering","korean","kernel",],
        "content": "top top -hv|-bcEeHiOSs1 -d secs -n max -u|U user -p pids -o field -w [cols] 단순한 사용 방법은 리눅스 top 정리 및 설명 을 참고하는 것이 좋습니다.\n또한, 표현된 각 column 외에도 다른 metric은 man 페이지를 통해 확인하실 수 있습니다.\n여기서는 top을 통해 살펴볼 수 있는 세부적인 여러 process 관련 정보들을 살펴보도록 하겠습니다.\ntask\n리눅스에서 프로세스와 스레드는 개념적으로 구분되지만, 내부적으로는 모두 \u0026lsquo;태스크\u0026rsquo;로 관리됩니다.\n리눅스 커널은 프로세스와 스레드를 동일한 기본 구조인 \u0026rsquo;task_struct\u0026rsquo;를 사용하여 표현합니다.\nsched.h top의 개선판들\nhtop , vtop , gtop , gotop memory virtual memory (메모리 가상화) A program selects a memory location using a virtual address. The processor translates this into a physical address and finally the memory controller selects the RAM chip corresponding to that address. 즉, 프로세스는 virtual address를 통해 메모리를 다루지만, 실제 physical address로의 변환은 processor가 수행하는 셈입니다.1\n정리하자면,\nvirtual address(가상 주소): 프로세스가 참조하는 주소 physical address(물리 주소): 실제 메모리 주소 이며, 특정 가상 주소가 어느 물리 주소에 매핑되어있는지 변환하는 과정을 수행하는 과정은 cpu(processor) 내의 MMU(Memory Management Unit)가 수행합니다. MMU의 역할을 다시 정리하자면, CPU에에서 컴파일된 코드 실행시 가상 주소 메모리 접근이 필요할 때 해당 주소를 물리 주소 값으로 변환해주는 하드웨어 장치입니다.\n가상 메모리 서브시스템의 실제 구현 세부 사항을 직접 확인해보고 싶다면 lwn의 관련 아티클2 을 참고할 수 있습니다.\nLinux Memory Types man 페이지에 따르면 프로세스가 소유한 메모리는 다음 4가지로 분류될 수 있습니다. 지금 당장 top의 출력물을 이해하는데 필요한 내용은 아니지만, 이후에 프로세스의 메모리 사용량을 살펴볼 때 필요한 내용이므로 간단히 정리해보도록 하겠습니다.\nPrivate | Shared 1 | 2 Anonymous . stack | . malloc() | . brk()/sbrk() | . POSIX shm* . mmap(PRIVATE, ANON) | . mmap(SHARED, ANON) -----------------------+---------------------- . mmap(PRIVATE, fd) | . mmap(SHARED, fd) File-backed . pgms/shared libs | 3 | 4 위 사분면에 근거하여, top의 각 세부 정보들을 대략적으로 설명하면 다음과 같습니다.\n우리가 흔히 메모리 영역을 heap, stack, data, code로 분류하곤 합니다. 이에 대해 관련 있는 내용은 다음과 같습니다.\nstack : quadrant 1에 해당합니다. 컴파일 타임에 크기가 결정됩니다. heap : quadrant 1에 해당하되 mmap을 통해 할당된 경우에도 속합니다. 우리가 흔히 쓰는 malloc이 qudrant 1에 속함을 확인해볼 수 있습니다. CODE : the `pgms\u0026rsquo; portion of quadrant 3 DATA : the entire quadrant 1 portion of VIRT plus all explicit mmap file-backed pages of quadrant 3 top의 출력물에서 관련있는 정보는 다음과 같습니다.\nVIRT : everything in-use and/or reserved (all quadrants) SHR : subset of RES (excludes 1, includes all 2 \u0026amp; 4, some 3) RES : anything occupying physical memory which, beginning with Linux-4.5, is the sum of the following three fields: RSan - quadrant 1 pages, which include any former quadrant 3 pages if modified RSfd - quadrant 3 and quadrant 4 pages RSsh - quadrant 2 pages memory commit 과정과 VIRT, RES, SHR 이제 종합적으로 프로세스가 처음 생성될 때 메모리를 할당 받는 과정인 memory commit을 살펴보겠습니다.\n가상 메모리 할당 (VIRT): 프로세스가 생성될 때, 커널은 해당 프로세스에 대해 가상 메모리 공간(VIRT)을 할당합니다. 이 공간은 프로세스가 사용할 수 있는 메모리의 최대 범위를 나타내지만, 처음에는 실제 물리 메모리에 할당되지 않습니다. 이것은 메모리를 효율적으로 관리하고, 실제로 필요할 때만 물리 메모리를 사용하도록 하는 것입니다.\n실제 메모리 할당과 페이지 폴트 (RES): 프로세스가 운영되는 동안, 특히 쓰기 작업이 시작될 때, 가상 메모리의 일부가 실제로 필요하게 됩니다. 이때 \u0026lsquo;페이지 폴트(page fault)\u0026lsquo;가 발생합니다. 페이지 폴트는 매핑된 물리적 메모리가 페이지 테이블에 존재하지 않을 때 발생하는 것으로, 이를 통해 커널은 해당 가상 메모리 공간에 대응하는 물리 메모리(RES)를 할당하게 됩니다.\n공유 메모리 (SHR): 공유 라이브러리와 같이 여러 프로세스에서 공유되는 메모리 영역은 SHR(공유 메모리)로 표시됩니다. 이러한 메모리는 다른 프로세스와 공유되는 물리적 메모리 주소를 가리키며, 각 프로세스의 가상 메모리 공간을 통해 동일한 물리적 메모리 주소를 참조하게 됩니다. 이는 메모리 사용의 효율성을 높이고, 중복을 방지하는 역할을 합니다.\nVIRT, RES, SHR에 대한 man 페이지 설명 1. VIRT -- Virtual Memory Size (KiB) The total amount of virtual memory used by the task. It includes all code, data and shared libraries plus pages that have been swapped out and pages that have been mapped but not used. 22. RES -- Resident Memory Size (KiB) A subset of the virtual address space (VIRT) representing the non-swapped physical memory a task is currently using. It is also the sum of the RSan, RSfd and RSsh fields. It can include private anonymous pages, private pages mapped to files (including program images and shared libraries) plus shared anonymous pages. All such memory is backed by the swap file represented separately under SWAP. Lastly, this field may also include shared file-backed pages which, when modified, act as a dedicated swap file and thus will never impact SWAP. 30. SHR -- Shared Memory Size (KiB) A subset of resident memory (RES) that may be used by other processes. It will include shared anonymous pages and shared file-backed pages. It also includes private pages mapped to files representing program images and shared libraries. memory overcommit 프로세스가 요구하는 메모리의 양은 결국 물리 메모리 공간의 한계를 넘을 수 없다.\n넘게 된다면 커널 파라미터인 vm.overcommit_memory의 정의에 따라 커널이 처리한다.3\nsysctl vm.overcommit_memory # can be 0, 1, 2 process status 맨 페이지를 통해 좀 더 자세한 내용을 살펴보자.\n29. S -- Process Status The status of the task which can be one of: D = uninterruptible sleep I = idle R = running S = sleeping T = stopped by job control signal t = stopped by debugger during trace Z = zombie D (uninterruptible sleep) i/o를 대기하고 있는 프로세스를 의미합니다. 프로세스가 D 상태라는 것은, run queue에서 나와 wait queue에서 대기하게 됨을 말합니다. 만약 i/o 작업이 완료되면 (예를 들어, read/write가 완료되면) 프로세스는 다시 R 상태가 됩니다. R 실제로 cpu를 사용하고 있는 프로세스를 의미합니다. S (interruptible sleep) sleep 상태입니다. D와 다른 점은, i/o가 아닌 단순 sleep이나 콘솔의 입력을 기다리는 경우에는 S 상태가 됩니다. T, t 프로세스를 디버거, strace 등으로 중단시킨 상태를 의미합니다. Z 좀비 프로세스입니다. 종료되었지만, 부모 프로세스에 의해 아직 회수(리소스 해제)되지 않은 프로세스입니다. 부모 프로세스가 자식 프로세스의 exit code(exit(int) 혹은 main return(int))을 요청해야 합니다. 보통 좀비 프로세스를 제거하기 위해서 child process의 종료 시그널을 받아 처리하는 방식을 사용하곤 합니다. 아래는 간략한 예시입니다.\nvoid handle_child(int sig) { if (sig == SIGCHLD) { int status; // 성공시 종료된 ps의 pid반환. // 특정 pid가 아닌 -1을 전달함으로써 임의의 자식 프로세스 종료를 처리함. pid_t id = waitpid(-1, \u0026amp;status, WNOHANG); // non blocking if (WIFEXITED(status)) { printf(\u0026#34;remove ps id : %d\\n\u0026#34;, id); printf(\u0026#34;child send : %d\\n\u0026#34;, WEXITSTATUS(status)); } } } int main(int argc, char* argv[]) { pid_t pid = 0; // signal handling struct sigaction act; act.sa_handler = handle_child; sigemptyset(\u0026amp;act.sa_mask); act.sa_flags = 0; sigaction(SIGCHLD, \u0026amp;act, 0); ... 생략 return 0; } PR, NI run queue에 잡힌 task들은 PR(priority)와 NI(nice)에 따라 스케쥴러의 알고리즘에 의해 cpu를 할당받게 됩니다.\n실제로 PR이 낮으면 먼저 dispatcher가 cpu에게 처리해줄 것을 요청한다. NI는 PR의 조정값으로, 우선순위는 PR + NI로 결정된다.\n예를 들어 process A의 PR: 10, NI: 0, process B의 PR: 10, NI: 5라면, process A가 10, process B가 15의 우선순위를 갖게 된다. 따라서 process A가 먼저 cpu를 할당받게 된다.\nrenice\nAlters the scheduling priority/niceness of one or more running processes.\nNiceness values range from -20 (most favorable to the process) to 19 (least favorable to the process).\nMore information: https://manned.org/renice .\n# Change priority of a running process: renice -n niceness_value -p pid # Change priority of all processes owned by a user: renice -n niceness_value -u user # Change priority of all processes that belong to a process group: renice -n niceness_value --pgrp process_group 이러한 가상(logical, virtual)과 물리(physical)의 분리는 메모리 뿐만 아니라 스토리지, 네트워크 등의 분야에서 자주 접하게 되는 패턴입니다. 물리를 감싸는 하나의 추상화된 레이어를 제공하여 파편화 해결, 공유화 등의 이점을 제공할 수 있습니다.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nhttps://lwn.net/Articles/253361/ \u0026#160;\u0026#x21a9;\u0026#xfe0e;\nhttps://mjmwired.net/kernel/Documentation/vm/overcommit-accounting \u0026#160;\u0026#x21a9;\u0026#xfe0e;\n", 
        "url": "https:\/\/darrenkwondev.github.io\/posts\/2023-12-27_kernel_study_02.md\/"
    },
    
    "https:\/\/darrenkwondev.github.io\/tags\/korean\/": {
        "title": "korean",
        "tags": [],
        "content": "", 
        "url": "https:\/\/darrenkwondev.github.io\/tags\/korean\/"
    },
    
    "https:\/\/darrenkwondev.github.io\/tags\/linux\/": {
        "title": "linux",
        "tags": [],
        "content": "", 
        "url": "https:\/\/darrenkwondev.github.io\/tags\/linux\/"
    },
    
    "https:\/\/darrenkwondev.github.io\/posts\/": {
        "title": "Posts",
        "tags": [],
        "content": "", 
        "url": "https:\/\/darrenkwondev.github.io\/posts\/"
    },
    
    "https:\/\/darrenkwondev.github.io\/tags\/system_engineering\/": {
        "title": "system_engineering",
        "tags": [],
        "content": "", 
        "url": "https:\/\/darrenkwondev.github.io\/tags\/system_engineering\/"
    },
    
    "https:\/\/darrenkwondev.github.io\/tags\/": {
        "title": "Tags",
        "tags": [],
        "content": "", 
        "url": "https:\/\/darrenkwondev.github.io\/tags\/"
    },
    
    "https:\/\/darrenkwondev.github.io\/tags\/cloud\/": {
        "title": "cloud",
        "tags": [],
        "content": "", 
        "url": "https:\/\/darrenkwondev.github.io\/tags\/cloud\/"
    },
    
    "https:\/\/darrenkwondev.github.io\/tags\/network\/": {
        "title": "network",
        "tags": [],
        "content": "", 
        "url": "https:\/\/darrenkwondev.github.io\/tags\/network\/"
    },
    
    "https:\/\/darrenkwondev.github.io\/posts\/2023-12-27_from-home-to-internet\/": {
        "title": "홈 네트워크 구성으로 알아보는 네트워크 기초",
        "tags": ["network","korean","cloud","system_engineering",],
        "content": " 네트워크 시리즈\n홈 네트워크 구성으로 알아보는 네트워크 기초 VM network와 도커 네트워크 (예정) VM으로 만드는 쿠버네티스 (예정) p2p 통신을 위해 NAT을 뚫는 홀펀칭(hole punching) (예정) private ip와 CIDR 보통 서버와 서버의 곧장 통신하는 경우도 있지만 ipv4가 부족한 현 상황에서는 ISP가 하나의 public ip(공인 ip)를 할당하며 해당 router는 내부 private ip를 public ip로 변환하는 일종의 문(gateway) 역할을 수행한다.\n흔히 말하는 공유기는 가정용 라우터 + NAT 등의 기능을 수행한다.\n이를 도식화하자면 다음과 같다.\nflowchart LR C(내부 기기, private ip) \u003c--\u003e B(gateway, NAT, PAT) \u003c--\u003e A(external) 이러한 구성은 홈 네트워크를 포함한 대부분의 네트워크에서 적용되는 구성이다.\nAWS 기준으로는 private subnet 대역에 존재하는 서버들은 직접적으로 외부 인터넷과 패킷을 주고 받을 수 없다. 이 부분은 NAT을 설명하면서 보충하도록 하겠다.\n일반적인 private ip의 대역은 다음과 같다.\nprivate ip 대역대 Class A : 10.0.0.0 ~ 10.255.255.255 (10.0.0.0/8) Class B : 172.16.0.0 ~ 172.31.255.255 (172.16.0.0/12) Class C : 192.168.0.0 ~ 192.168.255.255 (192.168.0.0/16) 현재 홈 네트워크에서 구성된 private 대역대를 ifconfig(linux), ip(linux), ipconfig(window) 등으로 확인할 수 있다. 여기서는 좀 더 간편한 설명을 위해 ipcalc를 통해 private ip 대역대를 확인해보자.\nipcalc 172.30.1.56 # 출력 결과 Address: 172.30.1.56 10101100.00011110.00000001. 00111000 Netmask: 255.255.255.0 = 24 11111111.11111111.11111111. 00000000 Wildcard: 0.0.0.255 00000000.00000000.00000000. 11111111 =\u0026gt; Network: 172.30.1.0/24 10101100.00011110.00000001. 00000000 HostMin: 172.30.1.1 10101100.00011110.00000001. 00000001 HostMax: 172.30.1.254 10101100.00011110.00000001. 11111110 Broadcast: 172.30.1.255 10101100.00011110.00000001. 11111111 Hosts/Net: 254 Class B, Private Internet 위 결과, 현재 명령을 실행한 컴퓨터의 private ip는 172.30.1.56 이며, CIDR block의 크기가 24임을 확인할 수 있다.\n이로써, 해당 홈 네트워크 주어진 호스트 대역은 172.30.1.0 ~ 172.30.1.255 까지이다. 해당 범위 내에서 개개인의 기기와 라우터(게이트웨이)의 주소가 할당된다. 보통은 DHCP에 의해 자동으로 할당된다.\n단, 가능한 호스트 영역 중 첫 주소(127.30.1.0)는 네트워크 식별 주소이며 마지막 주소(127.30.1.255)는 broadcast 주소로 선점되어 있다.\n구체적으로 홈 네트워크를 도식화하자면 다음과 같이 표현될 수 있다. 만약 새로운 network interface가 추가된다면, 해당 interface에 대한 주소가 위에서 언급한 호스트 대역 내로 자동 할당될 것이라 추측할 수 있다.\nflowchart LR A(PC A172.301.56) \u003c--\u003e R((router172.30.1.254)) C(PC B172.30.1.71) \u003c--\u003e R((router172.30.1.254)) PC A와 B 간에는 private ip를 통해 통신이 가능하다. 예를 들어 Window OS인 PC A에서 sshd를 실행하고, Mac OS로 구동 중인 PC B에서 ssh로 접속할 수 있다.\npublic ip와 router router의 주요 역할인 NAT과 port-forwarding에 대해 알아보겠습니다.\nNAT (Network Address Translation) private ip는 외부에서 접근할 수 없습니다. 외부에서 접근하려면 public ip로 변환되어야 합니다. 이를 위해 router는 NAT(Network Address Translation)을 수행합니다.\nNAT이란, 이름 그대로 네트워크 주소를 변환하는 기술이며 하나의 ip 주소를 다른 하나의 ip로 변환하는 것을 의미합니다. 이 과정은 NAT Table을 통해 이루어집니다. 보통은 여러 대의 기기가 public ip로 내부망에서 구별되며, 외부에서 바라보았을 때는 하나의 public ip로 보이게 됩니다.\n출처 : https://5kyc1ad.tistory.com/254 아래 명령어를 통해 간단히 홈 네트워크의 공유기에 할당된 public ip를 확인할 수 있습니다.\ncurl http://checkip.amazonaws.com curl http://icanhazip.com curl http://ifconfig.me 이러한 NAT 기술은, 퍼블릭 클라우드를 구성할 때도 사용됩니다.\n예를 들어, AWS의 VPC(Virtual Private Cloud)에서는 private subnet에 존재하는 사설 대역 ip의 서버들이 public subnet에 존재하는 NAT을 통해 public IP로 변환되어 외부와 통신하게 되어 egress[outbound]가 가능하지만, 외부 인터넷에서 ingress[inbound]는 안되는 상황을 구성할 수 있습니다.\nUse NAT gateway instead of NAT instance\nAWS에서 제공하는 NAT 게이트웨이라는 관리형 NAT 디바이스를 사용하거나, EC2 인스턴스에서 NAT 디바이스(여기서는 NAT 인스턴스라고 함)를 생성할 수 있습니다. NAT 게이트웨이는 더 나은 가용성과 대역폭을 제공하고 관리에 소요되는 작업이 줄어들기 때문에 권장합니다. - https://docs.aws.amazon.com/ko_kr/vpc/latest/userguide/vpc-nat.html port-forwarding 특정한 포트로 들어오는 데이터 패킷을 다른 포트로 바꿔서 다시 전송해주는 작업입니다. 대부분의 라우터가 지원하는 기능입니다. 라우터의 설정을 조정할 수 있는 페이지에서 직접 설정할 수 있음을 확인할 수 있습니다.\n출처 : https://m.blog.naver.com/kangyh5/221531520692 포트 포워딩을 통해 로컬 서버가 노출한 포트를 외부에 노출하지 않을 수 있는 장점이 있습니다. 서버를 배포할 때는 보통 포트를 숨기려고 하는데 필요한 서비스에서만 외부 접근을 허용하는 등의 보안적인 이유에서 입니다.\n이러한 보안책을 뚫기 위해서 포트 스캐닝을 하는 경우도 있습니다. 제 github에 간단한 포트 스캐닝 코드 를 작성해 놓았습니다.\nNAT과 port-forwarding을 통해 클라우드의 subnet 간 통신 이해하기 출처 : https://cloudneta.github.io/ 이제 우리는 위 도표를 홈 네트워크의 기술 이해에 기반해서 이해할 수 있습니다.\nprivate subnet에서 출발(private ip) → 목적지(목적 웹 서버) public subnet에 존재하는 NAT이 private IP를 또 다른 private IP로 변환합니다. 다수의 인스턴스에서 다른 private IP가 도착하더라도 하나의 private IP로 만듭니다. 추가로, 이 두 요청을 구분하기 위 PORT도 변환합니다. 변환된 후에는 public subnet의 RT를 참고하여 IGW로 이동합니다. NAT devices에서 PORT를 변환하므로 사실상 PAT이지만 관습적으로 이들을 구분해서 부르는 것 같지는 않습니다. IGW에서 private IP(NAT에 의해 변환됨)를 public IP로 변환하고 이로써 인터넷과 소통할 수 있게 됩니다. 역으로 인터넷에서 들어오는 경우도 위의 순서를 역으로 밟아가며 진행됩니다. 목적지 IP는 NAT에서 private로 변환되고 NAT은 변환 정보에 따라 다른 IP로 변환된다. ", 
        "url": "https:\/\/darrenkwondev.github.io\/posts\/2023-12-27_from-home-to-internet\/"
    },
    
    "https:\/\/darrenkwondev.github.io\/posts\/2023-12-27_kernel_study_01.md\/": {
        "title": "kernel study 01: 시스템 구성 정보 확인하기",
        "tags": ["linux","system_engineering","korean","kernel",],
        "content": " based on Ubuntu 22.04.3 LTS (GNU/Linux 5.15.0-91-generic aarch64) VM\n커널 정보 확인 uname (UNIX name) 커널 이름, 호스트 이름, 커널 버전, 커널 릴리즈, 운영 체제, 하드웨어 이름(아키텍처) 등 시스템 정보를 출력하는 도구\n# uname -a Linux drkup 5.15.0-91-generic #101-Ubuntu SMP Tue Nov 14 13:29:11 UTC 2023 aarch64 aarch64 aarch64 GNU/Linux 5.15.0-91-generic 커널을 사용 중임을 확인할 수 있다.\ndmesg (display message) 커널의 메시지 버퍼의 내용을 출력하는 도구.\nkernel이 부팅되면서 출력했된 내용을 살펴보겠습니다.\n# sudo dmesg | grep -i kernel | more # kernel 문자열을 포함한 로그만 출력해보았다. # 좌측 괄호 [] 안은 시스템 부팅 이후 경과한 시간을 초 단위를 표현한 것이다. # 커널 코드에 패치 적용 (시스템이 부팅되는 과정) [ 0.000000] alternatives: patching kernel code # 커널 파라미터. BOOT_IMAGE, root, ro 등이 보인다. [ 0.000000] Kernel command line: BOOT_IMAGE=/vmlinuz-5.15.0-91-generic root=/dev/mapper/ubuntu--vg-ubuntu--lv ro # 주어진 커널 파라미터이지만 인식하지 못하는 파라미터는 user space로 전달된다. [ 0.000000] Unknown kernel command line parameters \u0026#34;BOOT_IMAGE=/vmlinuz-5.15.0-91-generic\u0026#34;, will be passed to user space. # 커널이 인식하는 메모리 정보. # 시스템에 4194304K 메모리가 존재하며 3860508K가 사용 가능하다. [ 0.000000] Memory: 3860508K/4194304K available (17280K kernel code, 4576K rwdata, 13928K rodata, 9600K init, 1194K bss, 301028K reserved , 32768K cma-reserved) # 직접 메모리 액세스(DMA)에 사용되는 사전 할당된 메모리 풀 관련 로그 # CPU를 거치지 않고 메모리와 하드웨어 장치 간에 데이터를 직접 전송하기 위해 필요합니다. [ 0.084903] DMA: preallocated 512 KiB GFP_KERNEL pool for atomic allocations [ 0.085653] DMA: preallocated 512 KiB GFP_KERNEL|GFP_DMA pool for atomic allocations [ 0.086177] DMA: preallocated 512 KiB GFP_KERNEL|GFP_DMA32 pool for atomic allocations # 커널이 로드한 X.509 인증서 관련 로그 [ 0.744737] Loaded X.509 cert \u0026#39;Build time autogenerated kernel key: a3ee82ff8d989103803e60e521b19f3fabe02ee9\u0026#39; [ 0.746343] Loaded X.509 cert \u0026#39;Canonical Ltd. Kernel Module Signing: 88f752e560a1e0737e31163a466ad7b70a850c19\u0026#39; [ 0.797094] Loaded X.509 cert \u0026#39;Build time autogenerated kernel key: a3ee82ff8d989103803e60e521b19f3fabe02ee9\u0026#39; # 시스템 부팅 하면서 사용했던 메모리를 반환 [ 0.802006] Freeing unused kernel memory: 9600K # systemd 작업들. [ 3.234080] systemd[1]: Listening on udev Kernel Socket. [ 3.236727] systemd[1]: Mounting Kernel Debug File System... [ 3.241096] systemd[1]: Mounting Kernel Trace File System... [ 3.276186] systemd[1]: Starting Load Kernel Module chromeos_pstore... [ 3.278110] systemd[1]: Starting Load Kernel Module configfs... [ 3.283414] systemd[1]: Starting Load Kernel Module drm... [ 3.285204] systemd[1]: Starting Load Kernel Module efi_pstore... [ 3.290713] systemd[1]: Starting Load Kernel Module fuse... [ 3.298218] systemd[1]: Starting Load Kernel Module pstore_blk... [ 3.302885] systemd[1]: Starting Load Kernel Module pstore_zone... [ 3.305147] systemd[1]: Starting Load Kernel Module ramoops... [ 3.311579] systemd[1]: Starting Load Kernel Modules... [ 3.313671] systemd[1]: Starting Remount Root and Kernel File Systems... /boot/config-$(uname -r) 커널의 컴파일 옵션을 확인해보겠습니다. 특정 옵션이 활성화 되어 있어야만 사용할 수 있는 기능이 존재합니다. 예를 들어 ftrace를 사용하기 위해서는 CONFIG_FTRACE 옵션이 활성화 되어 있어야 합니다.\n#cat /boot/config-$(uname -r) | head -n 10 # 너무 많은 옵션이 존재하니 앞의 10줄 정도만 출력해보았습니다. # # Automatically generated file; DO NOT EDIT. # Linux/arm64 5.15.0-91-generic Kernel Configuration # CONFIG_CC_VERSION_=\u0026#34;gcc (Ubuntu 11.4.0-1ubuntu1~22.04) 11.4.0\u0026#34; CONFIG_CC_IS_GCC=y CONFIG_GCC_VERSION=110400 CONFIG_CLANG_VERSION=0 CONFIG_AS_IS_GNU=y CONFIG_AS_VERSION=23800 dmidecode (dmi : Desktop Management Interface) 하드웨어 정보를 보여주는 명령어입니다. 이 명령어는 시스템의 BIOS, 시스템 보드, 프로세서, 메모리 등과 같은 다양한 컴포넌트에 대한 상세한 정보를 제공합니다.\n가능한 타입을 나열하면 아래와 같습니다.\nValid type keywords are: bios system baseboard chassis processor memory cache connector slot dmidecode -t bios BIOS(Basic Input/Output System)를 확인해보겠습니다.\n# dmidecode -t bios # UTM VM에서 실행하여 흔히 보이는 vendor가 아닌 UEFI 환경임을 확인할 수 있습니다. # dmidecode 3.3 Getting SMBIOS data from sysfs. SMBIOS 3.0.0 present. Handle 0x0000, DMI type 0, 26 bytes BIOS Information # Vendor: EFI Development Kit II / OVMF Version: 0.0.0 Release Date: 02/06/2015 Address: 0xE8000 # bios가 메모리 상에서 위치한 시작 주소 Runtime Size: 96 kB # bios run time의 크기입니다. ROM Size: 64 kB Characteristics: BIOS characteristics not supported Targeted content distribution is supported UEFI is supported System is a virtual machine BIOS Revision: 0.0 dmidecode -t system 시스템 관련 정보를 출력해보겠습니다. 컴퓨터를 구성하는 다양한 하드웨어의 모델명 등을 확인할 수 있습니다.\n# dmidecode -t system # VM이라서 에뮬레이터인 QEMU를 사용하고 있음을 확인할 수 있습니다. # dmidecode 3.3 Getting SMBIOS data from sysfs. SMBIOS 3.0.0 present. Handle 0x0100, DMI type 1, 27 bytes System Information Manufacturer: QEMU Product Name: QEMU Virtual Machine Version: virt-7.2 Serial Number: Not Specified UUID: \u0026lt;omit\u0026gt; Wake-up Type: Power Switch SKU Number: Not Specified Family: Not Specified Handle 0x2000, DMI type 32, 11 bytes System Boot Information Status: No errors detected cpu1 /proc/cpuinfo # cat /proc/cpuinfo processor\t: 0 BogoMIPS\t: 48.00 Features\t: fp asimd evtstrm aes pmull sha1 sha2 crc32 atomics fphp asimdhp cpuid asimdrdm jscvt fcma lrcpc dcpop sha3 asimddp sha512 asimdfhm dit uscat ilrcpc flagm sb paca pacg dcpodp flagm2 frint CPU implementer\t: 0x00 CPU architecture: 8 CPU variant\t: 0x0 CPU part\t: 0x000 CPU revision\t: 0 (omit) dmidecode -t processor cpu(processor) 정보를 출력해보겠습니다.\n자주 출력해보는 내용이기 때문에 가상 머신이 아닌 타 기기에서 출력된 내용물을 가지고 설명해보겠습니다.\n장착된 cpu가 1개라고 인식되기 때문에 하나의 cpu 정보만 출력되었습니다. 만약 motherboard의 소켓에 여러 cpu를 장착했다면, 해당 갯수만큼 출력될 것입니다.\n흔히 물리적 cpu 코어의 갯수와 논리적 cpu 코어의 갯수를 헷갈리는데 해당 출력을 통해 명확히 구분할 수 있습니다. Socket Designation은 곧 cpu가 mother board에 장착된 소켓의 위치이며, Core Count는 장착된 하나의 cpu가 소유한 컴퓨팅 코어를 의미합니다. 아래 출력물을 기준으로 설명하자면, 물리적으로 cpu는 2개가 소켓에 장착되어 있으며 각각 8개의 코어를 가지고 있으며 하이퍼 쓰레딩이 적용되어 있어 하나의 코어당 2개 이상의 thread가 존재하는 것으로 확인됩니다.\n# dmidecode -t processor # dmidecode 3.3 Getting SMBIOS data from sysfs. SMBIOS 3.2.0 present. Handle 0x0400, DMI type 4, 48 bytes Processor Information Socket Designation: CPU 0 # cpu가 장착된 소켓의 이름입니다. MB에 cpu를 장착할 때 사용하는 소켓의 이름과 동일합니다. Type: Central Processor # cpu임을 나타냅니다. Family: Xeon Manufacturer: Intel ID: C3 06 03 00 FF FB EB BF Version: Intel(R) Xeon(R) CPU E5-2600 v4 Voltage: 1.2 V External Clock: 100 MHz Max Speed: 3000 MHz Current Speed: 3000 MHz Status: Populated, Enabled Upgrade: Socket LGA 2011 L1 Cache Handle: 0x0700 L2 Cache Handle: 0x0701 L3 Cache Handle: 0x0702 Serial Number: Not Specified Asset Tag: Not Specified Part Number: Not Specified Core Count: 8 # cpu가 소유한 물리적 core 갯수를 의미합니다. Core Enabled: 8 Thread Count: 16 # 일반적으로 하이퍼스레딩 또는 다중 스레딩 기술이 적용된 경우, 물리적 코어 수보다 스레드 수가 더 많습니다. Characteristics: 64-bit capable Multi-Core Hardware Thread # 다른 소켓에 장착된 cpu의 정보를 출력합니다. 해당 컴퓨터가 2개의 cpu를 장착하고 있음을 의미합니다. Handle 0x0401, DMI type 4, 48 bytes Processor Information Socket Designation: CPU 1 Type: Central Processor Family: Xeon Manufacturer: Intel ID: C3 06 03 00 FF FB EB BF Version: Intel(R) Xeon(R) CPU E5-2600 v4 Voltage: 1.2 V External Clock: 100 MHz Max Speed: 3000 MHz Current Speed: 3000 MHz Status: Populated, Enabled Upgrade: Socket LGA 2011 L1 Cache Handle: 0x0703 L2 Cache Handle: 0x0704 L3 Cache Handle: 0x0705 Serial Number: Not Specified Asset Tag: Not Specified Part Number: Not Specified Core Count: 8 Core Enabled: 8 Thread Count: 16 Characteristics: 64-bit capable Multi-Core Hardware Thread lscpu cpu와 관련된 정보를 출력하는 명령어입니다. dmidecode와 비슷한 역할을 하지만, 더 간단하게 출력해줍니다.\n특히, NUMA와 관련된 정보를 출력해주는 점이 차이점입니다.\n# lscpu Architecture: aarch64 CPU op-mode(s): 64-bit Byte Order: Little Endian CPU(s): 8 On-line CPU(s) list: 0-7 Vendor ID: 0x00 Model: 0 Thread(s) per core: 1 Core(s) per socket: 8 Socket(s): 1 Stepping: 0x0 BogoMIPS: 48.00 Flags: fp asimd evtstrm aes pmull sha1 sha2 crc32 atomics fphp asimdhp cpuid asimdrdm jscvt fcma lrcpc dcpop sha3 asimddp s ha512 asimdfhm dit uscat ilrcpc flagm sb paca pacg dcpodp flagm2 frint NUMA: NUMA node(s): 1 NUMA node0 CPU(s): 0-7 Vulnerabilities: Gather data sampling: Not affected Itlb multihit: Not affected L1tf: Not affected Mds: Not affected Meltdown: Not affected Mmio stale data: Not affected Retbleed: Not affected Spec rstack overflow: Not affected Spec store bypass: Vulnerable Spectre v1: Mitigation; __user pointer sanitization Spectre v2: Not affected Srbds: Not affected Tsx async abort: Not affected memory /proc/meminfo 메모리 정보를 출력하는 명령어입니다. 메모리의 총 용량, 사용량, 사용 가능한 용량 등을 확인할 수 있습니다.\n# cat /proc/meminfo | head -n 10 # 아주 많은 정보가 출력되기 때문에 앞의 10줄만 출력해보았습니다. MemTotal: 4004640 kB MemFree: 1628216 kB MemAvailable: 3582652 kB Buffers: 62432 kB Cached: 1957112 kB SwapCached: 0 kB Active: 623540 kB Inactive: 1451744 kB Active(anon): 1332 kB free # free total used free shared buff/cache available Mem: 4004640 225444 1628468 5380 2150728 3582876 Swap: 3001340 0 3001340 total = used + free + buff/cached\ntotal : Total installed memory (MemTotal and SwapTotal in /proc/meminfo) used : Used memory (= total - free - buffers - cache) 진짜로 사용되고 있는 영역이 아니라, buff/cache를 제외한 메모리를 말합니다. free : Unused memory (MemFree and SwapFree in /proc/meminfo) buff/cache = 디스크에 있는 파일이 메모리에 올라와 유지된 것들. 사실상 쓰고 있지만 used로 잡히지가 않음 buffers : Memory used by kernel buffers (Buffers in /proc/meminfo) 파일 정보, 파일의 메타 데이터를 의미합니다. cache : Memory used by the page cache and slabs (Cached and SReclaimable in /proc/meminfo) 파일의 실제 내용을 저장되는데 사용됩니다. 예를 들면 동영상 파일이 메모리에 올라와 있다면 buffer는 작겠지만 cache는 클 것이라 예측할 수 있다. shared : Memory used (mostly) by tmpfs (Shmem in /proc/meminfo) available : Estimation of how much memory is available for starting new applications, without swapping. 어떤 프로세스가 만들어진다면 메모리를 사용할 때 최대 어디까지 사용할 수 있는지를 의미합니다. 보통 buff/cache + free 정도로 계산됩니다. dmidecode -t memory dmidecode의 메모리 정보 출력물을 통해서, 메모리를 Physical Memory Array와 Memory Device로 구분하여 출력합니다.\n# dmidecode -t memory # dmidecode 3.3 Getting SMBIOS data from sysfs. SMBIOS 3.0.0 present. Handle 0x1000, DMI type 16, 23 bytes Physical Memory Array Location: Other Use: System Memory Error Correction Type: Multi-bit ECC Maximum Capacity: 4 GB Error Information Handle: Not Provided Number Of Devices: 1 Handle 0x1100, DMI type 17, 40 bytes Memory Device Array Handle: 0x1000 Error Information Handle: Not Provided Total Width: Unknown Data Width: Unknown Size: 4 GB Form Factor: DIMM Set: None Locator: DIMM 0 Bank Locator: Not Specified Type: RAM Type Detail: Other Speed: Unknown Manufacturer: QEMU Serial Number: Not Specified Asset Tag: Not Specified Part Number: Not Specified Rank: Unknown Configured Memory Speed: Unknown Minimum Voltage: Unknown Maximum Voltage: Unknown Configured Voltage: Unknown disk df (disk free) 각 파일 시스템이 마운트 된 곳과 용량을 출력합니다.\n/dev/mapper/ubuntu\u0026ndash;vg-ubuntu\u0026ndash;lv, /dev/vda1, /dev/vda2 3개의 파일 시스템이 확인됩니다. 마운트된 경로를 보니 vda1, vda2는 부트 파티션으로 사용되고 있고, ubuntu\u0026ndash;vg-ubuntu\u0026ndash;lv는 루트 파티션으로 사용되고 있음을 확인할 수 있습니다.\nVM 위의 파일 시스템이기 때문에 vda로 시작하는 이름을 가지고 있습니다. 일반적으로는 hda나 sda로 시작하는 이름을 가지고 있습니다.\ntmpfs 는 임시 파일 시스템을 의미합니다.\n# df -h (human readable) Filesystem Size Used Avail Use% Mounted on tmpfs 392M 1.4M 390M 1% /run /dev/mapper/ubuntu--vg-ubuntu--lv 15G 7.0G 6.5G 52% / tmpfs 2.0G 0 2.0G 0% /dev/shm tmpfs 5.0M 0 5.0M 0% /run/lock /dev/vda2 2.0G 129M 1.7G 8% /boot /dev/vda1 1.1G 6.4M 1.1G 1% /boot/efi tmpfs 392M 4.0K 392M 1% /run/user/1000 lsblk (list block devices) 블록 장치(디스크, 파티션, 논리 볼륨 등)에 대한 정보를 출력합니다. 특히, RAID 구성 여부를 확인할 수 있습니다.\n# lsblk NAME MAJ:MIN RM SIZE RO TYPE MOUNTPOINTS loop0 7:0 0 59.2M 1 loop /snap/core20/1977 loop1 7:1 0 109.6M 1 loop /snap/lxd/24326 loop2 7:2 0 46.4M 1 loop /snap/snapd/19459 loop3 7:3 0 35.5M 1 loop /snap/snapd/20298 sr0 11:0 1 1024M 0 rom vda 252:0 0 32G 0 disk ├─vda1 252:1 0 1G 0 part /boot/efi ├─vda2 252:2 0 2G 0 part /boot └─vda3 252:3 0 28.9G 0 part └─ubuntu--vg-ubuntu--lv 253:0 0 14.5G 0 lvm / MAJ:MIN: major, minor number. 커널이 해당 디스크를 식별하는 데 사용하는 고유 번호입니다. RM: 디스크의 제거 가능 여부 RO: 읽기 전용 여부 TYPE: 디스크의 타입. lvm(logical volume manager)를 사용하고 있음을 확인할 수 있습니다. RAID로 구성여부도 출력됩니다. MOUNTPOINTS: 마운트된 경로\nNAME MAJ:MIN RM SIZE RO TYPE MOUNTPOINT sda 8:0 0 1TB 0 disk ├─sda1 8:1 0 512M 0 part /boot/efi ├─sda2 8:2 0 2GB 0 part [SWAP] └─sda3 8:3 0 997.5G 0 part └─md0 9:0 0 1.9T 0 raid1 / sdb 8:16 0 1TB 0 disk ├─sdb1 8:17 0 512M 0 part ├─sdb2 8:18 0 2GB 0 part └─sdb3 8:19 0 997.5G 0 part └─md0 9:0 0 1.9T 0 raid1 / 위 예시에서 \u0026ldquo;sda\u0026quot;와 \u0026ldquo;sdb\u0026rdquo; 디스크는 RAID1으로 구성되었습니다. \u0026ldquo;md0\u0026quot;은 RAID 레이드 장치를 나타내며 \u0026ldquo;/dev/md0\u0026quot;는 RAID로 구성된 볼륨을 나타냅니다. RAID 구성은 여러 디스크의 복제 또는 데이터 분산을 허용하므로 \u0026ldquo;md0\u0026quot;의 하위 항목으로 \u0026ldquo;sda3\u0026quot;와 \u0026ldquo;sdb3\u0026quot;이 나타납니다.\nnetwork 네트워크 카드(NIC) 확인하기 lspci 명령어는 PCI 버스를 통해 연결된 장치들의 정보를 출력합니다. 여기서는 네트워크와 관련된 정보만을 grep하기 위해 grep 명령어를 사용하였습니다. 구체적으로, 서버가 사용하는 네트워크 카드(NIC)를 확인할 수 있습니다.\n# lspci | grep -i ether 00:01.0 Ethernet controller: Red Hat, Inc. Virtio network device ip로 network interface 확인 ifconfig 보다 ip 사용을 권장함. ifconfig는 유지 보수가 끝났으나 ip는 리눅스 커널과 같이 개발되며 지속적으로 유지보수되고 있음.\nip address # ip a로만 입력 가능 ip link # 네트워크 인터페이스 확인 ip neigh # ARP 테이블 (mac 주소) 확인하기 해당 글에서는 하드웨어적인 측면에서 살펴봐야하므로 ip 명령어에 대한 설명은 네트워크 인터페이스의 목록을 확인하는 것 정도로 마치겠습니다.\nip a 1: lo: \u0026lt;LOOPBACK,UP,LOWER_UP\u0026gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever inet6 ::1/128 scope host valid_lft forever preferred_lft forever 2: enp0s1: \u0026lt;BROADCAST,MULTICAST,UP,LOWER_UP\u0026gt; mtu 1500 qdisc fq_codel state UP group default qlen 1000 link/ether 1e:6f:22:b0:70:1e brd ff:ff:ff:ff:ff:ff inet 192.168.64.4/24 metric 100 brd 192.168.64.255 scope global dynamic enp0s1 valid_lft 72571sec preferred_lft 72571sec inet6 fd1d:e88a:d67e:2671:1c6f:22ff:feb0:701e/64 scope global dynamic mngtmpaddr noprefixroute valid_lft 2591943sec preferred_lft 604743sec inet6 fe80::1c6f:22ff:feb0:701e/64 scope link valid_lft forever preferred_lft forever 루프팩 인터페이스를 제외하고, enp0s1 인터페이스, en(이더넷), po(포트), s1(슬롯1)을 의미합니다.\nethtool 위에서 확인한 네트워크 인터페이스의 구체적인 정보를 확인해볼 수 있습니다. 안타깝게도 가상 머신에서는 정상적인 값을 출력하지 않으므로 타 기기의 출력물을 살펴보겠습니다.\nSupported link modes는 네트워크 카드가 지원하는 연결 모드를 의미합니다.\nAdvertised link modes는 네크워크 상 다른 장치와 연결 할 때 사용할 수 있는 연결 모드를 의미합니다.\n해당 네트워크 카드가 지원하는 연결 모드와 속도를 확인해보겠습니다.\nHalf Duplex and Full Duplex\nHalf Duplex -\u0026gt; 데이터가 한 번에 한 방향으로만 전송됨. Full Duplex -\u0026lt;\u0026gt; 데이터가 동시에 양방향으로 전송될 수 있음.\n10baseT/Half 10baseT/Full: 10 Mbps 속도의 Half Duplex와 Full Duplex 연결을 지원합니다. 100baseT/Half와 100baseT/Full: 각각 100 Mbps의 Half Duplex와 Full Duplex 연결을 지원합니다. 1000baseT/Full: 1000 Mbps (1 Gbps) 속도의 Full Duplex 연결을 지원합니다. Settings for enp0s1: Supported ports: [ TP ] Supported link modes: 10baseT/Half 10baseT/Full 100baseT/Half 100baseT/Full 1000baseT/Full Supported pause frame use: No Supports auto-negotiation: Yes Advertised link modes: 10baseT/Half 10baseT/Full 100baseT/Half 100baseT/Full 1000baseT/Full Advertised pause frame use: No Advertised auto-negotiation: Yes Link partner advertised link modes: Not reported Link partner advertised pause frame use: No Link partner advertised auto-negotiation: No Speed: 1000Mb/s # 현재 속도 Duplex: Full # duplex 지원 Port: Twisted Pair PHYAD: 0 Transceiver: internal Auto-negotiation: on MDI-X: off (auto) Supports Wake-on: pumbg Wake-on: g Current message level: 0x00000007 (7) drv probe link Link detected: yes # 정상적으로 연결되었음을 의미합니다. ethtool -g (ring buffer) NIC의 버퍼 공간인 ring buffer의 크기를 확인해볼 수 있습니다.\n패킷이 전달되면 ring buffer에 우선 복사된 후 커널에 의해 처리됩니다.\nring buffer가 너무 작다면 자주 커널에 의해 처리되어야 하므로 성능 저하가 발생할 수 있습니다.\n관습적으로 pre-set maximums와 같게 hardware settings을 맞춰야 합니다. 수정을 원한다면 -G 플래그를 통해 수정할 수 있습니다.\n# ethtool -g enp0s1 Ring parameters for enp0s1: Pre-set maximums: RX:\t256 RX Mini:\tn/a RX Jumbo:\tn/a TX:\t256 Current hardware settings: RX:\t256 RX Mini:\tn/a RX Jumbo:\tn/a TX:\t256 ethtool -k NIC 옵션을 확인할 수 있습니다.\ntcp-offload 기능을 통해 mtu 이상의 크기를 가진 패킷의 분할 작업을 cpu가 아닌 NIC가 처리하도록 할 수 있습니다. 그러나 네트워크 대역폭이 높은 서버와 같이 특정 환경에서는 불특정한 패킷 유실이 발생할 수 있어 off 시키곤 합니다.\n# ethtool -k enp0s1 | head -n 10 Features for enp0s1: rx-checksumming: off [fixed] tx-checksumming: off tx-checksum-ipv4: off [fixed] tx-checksum-ip-generic: off [fixed] tx-checksum-ipv6: off [fixed] tx-checksum-fcoe-crc: off [fixed] tx-checksum-sctp: off [fixed] scatter-gather: off tx-scatter-gather: off [fixed] ethtool -i NIC의 커널 드라이버 정보를 확인할 수 있습니다.\nethtool -i enp0s1 driver: virtio_net version: 1.0.0 firmware-version: expansion-rom-version: bus-info: 0000:00:01.0 supports-statistics: yes supports-test: no supports-eeprom-access: no supports-register-dump: no supports-priv-flags: no cpu의 개략적인 내용은 cpu.land 의 문서를 확인해보는 것이 좋습니다.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n", 
        "url": "https:\/\/darrenkwondev.github.io\/posts\/2023-12-27_kernel_study_01.md\/"
    },
    
    "https:\/\/darrenkwondev.github.io\/about\/": {
        "title": "About \u0026 Contact",
        "tags": [],
        "content": "I\u0026rsquo;m a programmer with two entrepreneurship experiences.\nStudy and develop tech to make a business impact.\nBut also focus on low-level details to avoid pitfalls of leaky abstraction.\nresume english resume (not yet! sorry!)\nkorean resume social github linkedin ", 
        "url": "https:\/\/darrenkwondev.github.io\/about\/"
    },
    
    "https:\/\/darrenkwondev.github.io\/categories\/": {
        "title": "Categories",
        "tags": [],
        "content": "", 
        "url": "https:\/\/darrenkwondev.github.io\/categories\/"
    },
    
}
</script>
<script defer src="/js/lunr.js"></script>
<script defer src="/js/search.js"></script>




</footer>

</body>
</html>

